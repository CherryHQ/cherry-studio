# RFC 评审报告：文件管理（单一节点表 + 文件树）

## 评审结论

**方向正确，但尚未达到可实施状态。** RFC 准确识别了现有架构的核心问题，提出的"节点表 + 引用关系"模型是合理的抽象。但在笔记集成策略、UUID 文件名与人类可读文件名的矛盾、引用清理机制、以及与 v2 迁移的整合等方面存在显著的未定义区域。

---

## 一、合理性分析

### 1.1 问题识别：准确且有代码实证

RFC 引用的 13 个问题均经代码验证属实：

| 问题 | 代码实证 | 严重程度 |
|------|---------|---------|
| P1/P2 职责割裂 & 非原子上传 | `FileStorage.ts`(main) 写物理文件，`FileManager.ts:59-73`(renderer) 写 Dexie，两步之间无事务 | **高** |
| P3 渲染进程可绕过 main | `FileManager.addFile()` 直接写 `db.files`，不经 main 验证 | **高** |
| P4 去重与用户感知冲突 | `findDuplicateFile()` 按 size+MD5 合并，用户无法区分同内容不同文件 | **中** |
| P5/P7 引用语义不足 | `count` 字段为纯数字，无法追溯谁引用了文件 | **高** |
| P9/P10 笔记体系割裂 | `NotesTreeNode` 与 `FileMetadata` 完全独立，笔记不进 `db.files` | **中** |
| P13 元数据生成不一致 | `ext` 有时含点有时不含，`type` 推断逻辑分散在 main/renderer 多处 | **低** |

### 1.2 "单一节点表 + 文件树"：合理的抽象

- **邻接表模型** (`parent_id`) 是成熟模式，项目内 `messageTable` 已使用类似的 `parentId` 结构。
- **文件 + 目录同表** 减少了 JOIN 复杂度，也为目录级操作（递归删除、移动）提供了统一语义。
- 与 v2 迁移方向一致（Dexie → SQLite/Drizzle），可以直接作为新 schema 落地。

### 1.3 放弃去重：正确的取舍

当前 `findDuplicateFile()` 的代价：

- 每次上传扫描 **全部** 已存储文件（O(n)），计算 MD5。
- 桌面应用磁盘空间充裕，去重节省的空间不值得 UX 损失。
- 去重导致 `origin_name` 信息丢失，用户无法区分文件。

RFC 正确保留了"重复检查提示"的选项，让用户自行决定，这是合理的。

### 1.4 引用关系表：设计基本合理，需要细化

`file_ref` 表的多态关联设计 `(node_id, source_type, source_id, role)` 是标准做法，但存在以下需要细化的地方：

1. **`source_id` 的粒度**：对话消息中，文件引用在 `FileBlock`（block 级），不在 `Message` 级。`source_id` 应为 block ID 还是 message ID？建议使用 message ID + role 区分，避免过度碎片化。
2. **`source_type` 枚举需对齐 v2 数据模型**：当前 block 类型包括 `FileBlock`、`ImageBlock`、`VideoBlock`，它们的 `source_type` 是否统一为 `chat_message`？
3. **`role` 语义需严格定义**：`attachment`（聊天附件）、`source`（知识库来源）、`asset`（生成资产）至少三个。paintings（绘图）生成的图片属于 `asset` 但 RFC 未提及。
4. **级联清理策略**：`source_id` 是多态的（可能是 message ID、knowledge item ID 等），无法用 FK 约束。删除业务对象时必须由应用层同步清理 `file_ref`，这是**关键的遗漏**。

---

## 二、可行性分析

### 2.1 与 v2 迁移的整合：最关键的可行性问题

**现状**：

- Dexie `db.files` 已标记 `@deprecated Scheduled for removal in v2.0.0`。
- v2 已有完整迁移框架（`MigrationEngine` → `ChatMigrator` 等）。
- Message schema 已迁移到 SQLite/Drizzle。

**建议**：文件管理重构应**作为 v2 迁移的一部分**，而非独立进行：

1. 新增 Drizzle schema（`nodeTable` + `fileRefTable`）到 `src/main/data/db/schemas/`。
2. 新增 `FileMigrator` 到迁移框架中。
3. 迁移逻辑：扫描旧 `db.files` → 创建 node 记录 → 扫描所有 message blocks 和 knowledge items → 重建 `file_ref` 记录。

### 2.2 运行时路径构建：可行，需缓存

RFC 提出不持久化 `path`，由树关系运行时构建。这是正确的规范化设计。

- **典型场景**：文件树深度 1-5 层，SQLite 递归 CTE 毫秒级完成。
- **热路径风险**：`getFilePath()` / `getFileUrl()` 被频繁调用（渲染消息列表时）。
- **建议**：维护内存级路径缓存 `Map<nodeId, absolutePath>`，树变更时重建。树操作（上传/删除/移动）频率远低于读取。

### 2.3 main 进程统一写入：可行

v2 的 DataApi 模式已经证明了这个方向：

- `DataApiService` → `ApiServer` → Handlers → Services → DB。
- 渲染进程通过 `useQuery` / `useMutation` 与 main 交互。
- 文件节点操作可以完全按此模式实现。

### 2.4 迁移影响范围：大

`FileMetadata` 类型被 **64+ 文件** 引用，涉及：

- AI 核心：`fileProcessor.ts`、`messageConverter.ts`、多个 API 客户端。
- 知识库：`KnowledgeService.ts`、6+ 个预处理 provider。
- UI：文件页面、消息 block 组件、绘图页面。
- 状态管理：`messageThunk.ts`、`knowledgeThunk.ts`。

**迁移策略应分阶段**，先建立新数据层（节点表 + 引用表），再逐步替换 `FileMetadata` 的消费方。

---

## 三、关键缺陷与风险

### 3.1 UUID 文件名 vs 人类可读文件名的矛盾（最大设计缺陷）

RFC 第 43 行声称"节点应当保证与 OS 文件系统的目录结构保持一致"，第 72 行声称"目录结构可在 OS 中直接查看与维护"。

**但同时**，第 129 行说"底层存储文件名为 `id + ext`"。

这两者**不可兼得**：

- `id + ext` 文件名（如 `a1b2c3d4.pdf`）→ OS 中不可读，"直接查看"无意义。
- 人类可读文件名（如 `My Report.pdf`）→ 需要处理名称冲突、OS 保留字符等。

**更重要的是，笔记系统必须使用人类可读文件名**：

- 用户在外部编辑器（VS Code、Obsidian）中编辑笔记。
- 笔记 markdown 文件可能互相引用。
- 迁移到 UUID 命名会**彻底破坏笔记的外部编辑工作流**。

**建议**：RFC 应明确区分两种存储模式：

1. **托管文件**（聊天附件、知识库文件、生成图片）：`id + ext`，存储在 `{appData}/Data/Files/`。
2. **外部文件**（笔记）：`name + ext`，存储在用户配置目录，通过文件监听同步。

### 3.2 笔记迁移策略完全缺失

RFC 仅说"笔记体系需要迁移到本文件树架构之下"，但没有任何具体方案。这是整个 RFC 中**最复杂的部分**：

- 笔记当前依赖文件系统扫描 + chokidar 监听。
- 外部编辑器创建/重命名/删除笔记文件时，需要同步到节点表。
- 这是一个 **文件系统 → DB 双向同步** 问题，而非简单的一次性迁移。
- 防抖、批处理、冲突解决（Cherry Studio 与外部编辑器同时操作）都需要设计。

### 3.3 引用清理机制缺失

当业务对象被删除时（如删除对话、清空知识库），对应的 `file_ref` 记录如何清理？

- `source_id` 是多态字段，无法用数据库外键约束。
- **必须**在每个删除路径中手动清理 `file_ref`。
- 遗忘任一路径都会导致悬挂引用堆积。
- 建议增加定期清理任务（扫描 `file_ref` 中 `source_id` 不存在于对应表的记录）。

### 3.4 其他缺失项

| 缺失项 | 影响 | 建议 |
|--------|-----|------|
| 软删除/回收站 | 用户误删无法恢复 | 增加 `deleted_at` 字段 |
| 并发访问 | 多窗口同时操作文件 | 明确锁策略或乐观并发控制 |
| 全文搜索 | 节点表缺少 FTS 能力 | 参照 message 表的 FTS5 方案 |
| 绘图(paintings)系统 | RFC 未提及此业务来源 | 补充到 `source_type` 枚举 |
| 错误恢复 | 文件系统操作不可回滚 | 设计"写文件 → 写 DB → 确认"的补偿逻辑 |
| 导出/备份 | UUID 命名的文件对用户无意义 | 导出时应恢复原始文件名 |
| 具体 Drizzle Schema | 无法验证字段设计是否可落地 | 补充草案 schema |

---

## 四、改进建议

### 4.1 RFC 应补充的内容

1. **两种存储模式的明确区分**（托管 vs 外部）。
2. **笔记集成的详细方案**（文件系统 ↔ DB 双向同步策略）。
3. **引用清理机制**（应用层级联 + 定期扫描）。
4. **具体 Drizzle Schema 草案**（含索引、约束）。
5. **API 层设计**（DataApi handler 接口定义）。
6. **分阶段实施计划**：
   - Phase 1: 节点表 + 基础 CRUD（替换 `db.files`）。
   - Phase 2: 引用关系表（替换 `count`）。
   - Phase 3: 笔记集成（文件系统同步）。
   - Phase 4: 业务接入（对话复用、统一检索）。
7. **迁移回滚策略**（迁移失败时的降级方案）。

### 4.2 可以简化的地方

- **挂载点/根节点** 概念在初期可以硬编码为两个固定根：`Files`（托管）和 `Notes`（外部），不需要通用的挂载机制。
- **`meta` 字段** 建议初期不实现，避免过度设计。具体需求出现时再加。
- **目录节点的引用关系** 初期可以禁止，只允许文件节点建立引用。

---

## 五、总结评分

| 维度 | 评分 | 说明 |
|------|------|------|
| 问题识别 | ★★★★★ | 13 个问题全部有代码实证，分析准确 |
| 方向选择 | ★★★★☆ | 节点表 + 引用关系是正确方向，放弃去重是正确取舍 |
| 模型设计 | ★★★☆☆ | 基本合理但 UUID 文件名与笔记需求矛盾未解决 |
| 完整度 | ★★☆☆☆ | 缺少笔记迁移策略、引用清理、Schema 定义、分阶段计划 |
| 可实施性 | ★★☆☆☆ | 需要大量补充设计才能开始编码 |

**总体判断**：RFC 作为**方向性文档**是合格的，作为**实施指南**尚不充分。建议在以下问题解决后进入实施：

1. 明确托管文件 vs 外部文件的双模式设计。
2. 补充笔记集成的详细方案。
3. 编写 Drizzle Schema 草案并验证。
4. 制定与 v2 迁移整合的分阶段计划。
