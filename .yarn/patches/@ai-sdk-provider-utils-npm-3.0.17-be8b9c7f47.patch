diff --git a/dist/index.js b/dist/index.js
index 5337e905da76181abeb37fd0bc737f29fa80b829..e83a4795d0a0c4a7c6f01dc6f870598240d7136b 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -91,14 +91,42 @@ __export(src_exports, {
 module.exports = __toCommonJS(src_exports);
 
 // src/combine-headers.ts
+const MERGE_HEADERS = new Set([
+  'anthropic-beta'
+  // Add other comma-separated list headers here if needed
+]);
+
 function combineHeaders(...headers) {
-  return headers.reduce(
-    (combinedHeaders, currentHeaders) => ({
-      ...combinedHeaders,
-      ...currentHeaders != null ? currentHeaders : {}
-    }),
-    {}
-  );
+  const result = {};
+
+  for (const headerGroup of headers) {
+    if (!headerGroup) continue;
+
+    for (const [key, value] of Object.entries(headerGroup)) {
+      if (value === undefined) continue;
+
+      // For headers that should be merged, combine comma-separated values
+      if (MERGE_HEADERS.has(key)) {
+        const existingValue = result[key];
+        if (existingValue) {
+          // Split, trim, deduplicate, and rejoin
+          const existingValues = existingValue.split(',').map(v => v.trim());
+          const newValues = value.split(',').map(v => v.trim());
+          const uniqueValues = Array.from(
+            new Set([...existingValues, ...newValues])
+          );
+          result[key] = uniqueValues.join(',');
+        } else {
+          result[key] = value;
+        }
+      } else {
+        // For other headers, simple overwrite (standard HTTP semantics)
+        result[key] = value;
+      }
+    }
+  }
+
+  return result;
 }
 
 // src/convert-async-iterator-to-readable-stream.ts
diff --git a/dist/index.mjs b/dist/index.mjs
index 1e607fa1faf735fe854308d898bf3a21d949d515..d08bc531f22a3ad109aab167bd439360426608c8 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -1,12 +1,40 @@
 // src/combine-headers.ts
+const MERGE_HEADERS = new Set([
+  'anthropic-beta'
+  // Add other comma-separated list headers here if needed
+]);
+
 function combineHeaders(...headers) {
-  return headers.reduce(
-    (combinedHeaders, currentHeaders) => ({
-      ...combinedHeaders,
-      ...currentHeaders != null ? currentHeaders : {}
-    }),
-    {}
-  );
+  const result = {};
+
+  for (const headerGroup of headers) {
+    if (!headerGroup) continue;
+
+    for (const [key, value] of Object.entries(headerGroup)) {
+      if (value === undefined) continue;
+
+      // For headers that should be merged, combine comma-separated values
+      if (MERGE_HEADERS.has(key)) {
+        const existingValue = result[key];
+        if (existingValue) {
+          // Split, trim, deduplicate, and rejoin
+          const existingValues = existingValue.split(',').map(v => v.trim());
+          const newValues = value.split(',').map(v => v.trim());
+          const uniqueValues = Array.from(
+            new Set([...existingValues, ...newValues])
+          );
+          result[key] = uniqueValues.join(',');
+        } else {
+          result[key] = value;
+        }
+      } else {
+        // For other headers, simple overwrite (standard HTTP semantics)
+        result[key] = value;
+      }
+    }
+  }
+
+  return result;
 }
 
 // src/convert-async-iterator-to-readable-stream.ts
